#!/usr/bin/env ruby
require 'json'
require 'yaml'

# Replay score submissions from JSON-formatted production logs
#
# Usage:
#   bin/replay config.yml           # Run with config file
#   bin/replay --dry-run config.yml # Show what would be replayed without making changes
#   bin/replay                      # Generate sample config file
#
# Config file format (YAML):
#   database: db/2025-annapolis-gratitude-gala.sqlite3
#   log: ~/Downloads/2025-12-07.log
#   tenant: 2025-annapolis-gratitude-gala
#   start: 2025-12-07T12:00:00Z     # optional
#   finish: 2025-12-07T15:00:00Z    # optional
#   methods:                         # optional, defaults to both
#     - post
#     - post_feedback

DRY_RUN = ARGV.delete('--dry-run')

if ARGV.empty?
  config = {
    database: 'db/2025-annapolis-gratitude-gala.sqlite3',
    log: File.join(Dir.home, 'Downloads/2025-12-07.log'),
    tenant: '2025-annapolis-gratitude-gala',
    start: nil,
    finish: nil,
    methods: ['post', 'post_feedback'],
  }

  config_path = File.join(Dir.home, 'tmp/replay-config.yml')
  IO.write(config_path, config.to_yaml)
  puts "Sample config written to #{config_path}"
  puts "Edit the file and run: bin/replay #{config_path}"
  exit
end

config = YAML.load_file(ARGV.first, symbolize_names: true)

# Expand ~ in paths
config[:log] = File.expand_path(config[:log])
config[:database] = File.expand_path(config[:database])

# Bootstrap Rails if needed
if !defined?(Rails)
  ENV['RAILS_APP_DB'] = config[:database]
  args = [DRY_RUN ? '--dry-run' : nil, ARGV.first].compact
  exec "bin/run", config[:database], $0, *args
end

puts "Replaying scores from #{config[:log]}"
puts "Target database: #{config[:database]}"
puts "Tenant: #{config[:tenant]}"
puts "DRY RUN - no changes will be made" if DRY_RUN
puts

# Parse log and collect requests by request_id
requests = Hash.new { |h, k| h[k] = {} }
target_tenant = config[:tenant]
methods = config[:methods] || ['post', 'post_feedback']

File.foreach(config[:log], chomp: true, encoding: 'UTF-8') do |line|
  # Extract JSON from log line (format: timestamp [host] region [undefined] {json})
  json_match = line.match(/\{.*\}$/)
  next unless json_match

  begin
    data = JSON.parse(json_match[0])
  rescue JSON::ParserError
    next
  end

  next unless data['tenant'] == target_tenant
  next unless data['request_id']

  timestamp = data['@timestamp']

  # Apply time filters
  next if config[:start] && timestamp < config[:start]
  next if config[:finish] && timestamp > config[:finish]

  request_id = data['request_id']
  message = data['message']

  if message&.include?('Started POST')
    if match = message.match(/Started POST "([^"]+)"/)
      requests[request_id][:path] = match[1]
      requests[request_id][:time] = timestamp
    end
  elsif message&.include?('Processing by ScoresController#')
    if match = message.match(/ScoresController#(\w+)/)
      requests[request_id][:method] = match[1]
    end
  elsif message&.include?('Parameters:')
    if match = message.match(/Parameters: (\{.*\})/)
      # Convert Ruby hash syntax to something we can eval
      params_str = match[1]
      begin
        requests[request_id][:parameters] = eval(params_str)
      rescue SyntaxError, StandardError
        # Skip malformed parameters
      end
    end
  end
end

# Filter to complete requests with score data
requests.select! { |_, r| r[:time] && r[:method] && r[:parameters] }
requests.select! { |_, r| methods.include?(r[:method]) }
requests.select! { |_, r| r[:parameters]['heat'] && (r[:parameters]['score'] || r[:parameters]['comments']) }

# Sort by time
sorted_requests = requests.sort_by { |_, r| r[:time] }

puts "Found #{sorted_requests.length} score submissions to replay"
puts

# Replay each request
replayed = 0
skipped = 0
errors = 0

sorted_requests.each do |request_id, request|
  params = request[:parameters]
  method = request[:method]
  time = request[:time]

  judge_id = params['judge'].to_i
  heat_id = params['heat'].to_i

  begin
    judge = Person.find(judge_id)
    heat = Heat.find(heat_id)
  rescue ActiveRecord::RecordNotFound => e
    puts "SKIP [#{time}] #{method}: #{e.message}"
    skipped += 1
    next
  end

  score = Score.find_or_initialize_by(judge_id: judge.id, heat_id: heat.id)
  changes = []

  # Handle comments (from both post and post_feedback)
  if params['comments'] && !params['comments'].empty?
    if score.comments != params['comments']
      changes << "comments"
      score.comments = params['comments'] unless DRY_RUN
    end
  end

  # Handle good/bad fields (checkbox scoring)
  if params['good']
    if score.good != params['good']
      changes << "good=#{params['good']}"
      score.good = params['good'] unless DRY_RUN
    end
  end
  if params['bad']
    if score.bad != params['bad']
      changes << "bad=#{params['bad']}"
      score.bad = params['bad'] unless DRY_RUN
    end
  end

  # Handle score value
  score_value = params['score']
  if score_value && !score_value.is_a?(Hash)
    if params['name']
      # Named score component (solo 4-part scoring) - merge into JSON
      existing_value = score.value&.start_with?('{') ? JSON.parse(score.value) : {}
      if existing_value[params['name']] != score_value
        existing_value[params['name']] = score_value
        changes << "#{params['name']}=#{score_value}"
        score.value = existing_value.to_json unless DRY_RUN
      end
    else
      # Simple score value
      if score.value != score_value
        changes << "value=#{score_value}"
        score.value = score_value unless DRY_RUN
      end
    end
  end

  if changes.empty?
    skipped += 1
    next
  end

  if DRY_RUN
    puts "WOULD UPDATE [#{time}] heat=#{heat_id} judge=#{judge_id}: #{changes.join(', ')}"
  else
    score.save!
    puts "UPDATED [#{time}] heat=#{heat_id} judge=#{judge_id}: #{changes.join(', ')}"
  end
  replayed += 1

rescue => e
  puts "ERROR [#{time}] #{method} heat=#{heat_id}: #{e.message}"
  errors += 1
end

puts
puts "Summary:"
puts "  Replayed: #{replayed}"
puts "  Skipped:  #{skipped}"
puts "  Errors:   #{errors}"
