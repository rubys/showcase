#!/usr/bin/env ruby

require 'net/http'
require 'uri'
require 'json'
require 'open3'
require 'optparse'

# Disable output buffering for real-time progress updates
$stdout.sync = true

# Step 0: Generate and prepare maps (before syncing)
puts "Step 0: Generating map files..."
puts "=" * 50

script_path = File.expand_path('generate_and_upload_maps.rb', __dir__)
ruby_path = RbConfig.ruby
stdout, stderr, status = Open3.capture3(ruby_path, script_path)

puts stdout unless stdout.empty?
puts stderr unless stderr.empty?

unless status.success?
  puts "Error: Map generation failed with exit code #{status.exitstatus}"
  exit 1
end

puts "\n"

# Step 0.5: Sync showcase dates from event databases
puts "Step 0.5: Syncing showcase dates..."
puts "=" * 50

require_relative '../lib/showcase_date_sync'
result = ShowcaseDateSync.sync(quiet: false)

if result[:updated].any?
  puts "Updated #{result[:updated].length} date(s)"
else
  puts "All dates up to date"
end

if result[:errors].any?
  puts "#{result[:errors].length} error(s) occurred"
end

puts "\n"

# Parse command line options
options = { verbose: false, dry_run: false, target: 'fly' }
OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]"
  opts.separator ""
  opts.separator "Updates the index database and triggers updates on deployment servers"
  opts.separator ""
  opts.separator "Options:"

  opts.on("-v", "--verbose", "Verbose output") do
    options[:verbose] = true
  end

  opts.on("--dry-run", "Show what would be done without making changes") do
    options[:dry_run] = true
  end

  opts.on("-t", "--target TARGET", [:fly, :kamal], "Target platform (fly, kamal). Default: fly") do |t|
    options[:target] = t
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit 0
  end
end.parse!

# Step 1: Sync index database
puts "Step 1: Syncing index database..."
puts "=" * 50

if options[:target] == :kamal
  # Kamal target: Direct rsync to showcase.party (skip S3 and webhook)
  git_path = File.realpath(File.expand_path('..', __dir__))
  dbpath = ENV.fetch('RAILS_DB_VOLUME') { "#{git_path}/db" }
  index_db = File.join(dbpath, 'index.sqlite3')

  unless File.exist?(index_db)
    puts "Error: index.sqlite3 not found at #{index_db}"
    exit 1
  end

  rsync_cmd = "rsync -av --update #{dbpath}/index.sqlite3 showcase.party:db/"

  if options[:dry_run]
    puts "Would run: #{rsync_cmd}"
  else
    puts "$ #{rsync_cmd}"
    stdout, stderr, status = Open3.capture3(rsync_cmd)

    puts stdout unless stdout.empty?
    puts stderr unless stderr.empty?

    unless status.success?
      puts "Error: rsync to showcase.party failed with exit code #{status.exitstatus}"
      exit 1
    end

    puts "Successfully synced index.sqlite3 to showcase.party"
  end
else
  # Fly target: Use S3 sync with webhook
  script_path = File.expand_path('sync_databases_s3.rb', __dir__)

  if options[:dry_run]
    puts "Would run: ruby #{script_path} --index-only"
  else
    # Use RbConfig.ruby to ensure we use the same Ruby version as the parent process
    ruby_path = RbConfig.ruby
    cmd_args = [ruby_path, script_path, '--index-only']
    cmd_args << '--verbose' if options[:verbose]
    stdout, stderr, status = Open3.capture3(*cmd_args)

    puts stdout
    puts stderr unless stderr.empty?

    unless status.success?
      puts "Error: Index sync failed with exit code #{status.exitstatus}"
      exit 1
    end
  end
end

puts "\n"

# Step 2: Get list of deployment targets
if options[:target] == :kamal
  puts "Step 2: Target platform - Kamal"
else
  puts "Step 2: Getting list of Fly machines..."
end
puts "=" * 50

if options[:target] == :kamal
  # Kamal target: single server
  machine_ids = ['showcase.party']
  puts "Will update Kamal server: showcase.party"
  puts "\n"
else
  # Fly.io target: discover active machines
  # Check if flyctl CLI is available
  # First check for ~/bin/flyctl, then check system PATH
  flyctl_cmd = nil
  home_flyctl = File.expand_path('~/bin/flyctl')

  if File.exist?(home_flyctl) && File.executable?(home_flyctl)
    flyctl_cmd = home_flyctl
    puts "Using flyctl from: #{flyctl_cmd}" if options[:verbose]
  else
    flyctl_check, _, _ = Open3.capture3('which', 'flyctl')
    if !flyctl_check.empty?
      flyctl_cmd = 'flyctl'
      puts "Using system flyctl" if options[:verbose]
    end
  end

  if flyctl_cmd.nil?
    puts "Error: 'flyctl' CLI not found. Please install the Fly CLI first."
    puts "Visit: https://fly.io/docs/flyctl/install/"
    puts "Or place flyctl in ~/bin/flyctl"
    exit 1
  end

  machines_output, machines_stderr, machines_status = Open3.capture3({'LOG_LEVEL' => 'error'}, flyctl_cmd, 'machines', 'list', '--json')

  unless machines_status.success?
    puts "Error: Failed to get machines list"
    puts machines_stderr unless machines_stderr.empty?
    exit 1
  end

  # Parse JSON output to get machine IDs and states
  begin
    machines = JSON.parse(machines_output)
  rescue JSON::ParserError => e
    puts "Error: Failed to parse machines JSON: #{e.message}"
    exit 1
  end

  if machines.empty?
    puts "No machines found"
    exit 0
  end

  # Filter out stopped and suspended machines
  # Only include machines with state: "started" or "created"
  active_machines = machines.select { |m| ['started', 'created'].include?(m['state']) }
  skipped_machines = machines.reject { |m| ['started', 'created'].include?(m['state']) }

  machine_ids = active_machines.map { |m| m['id'] }

  puts "Found #{machines.length} total machines"
  if skipped_machines.any?
    puts "Skipping #{skipped_machines.length} stopped/suspended machines:"
    skipped_machines.each do |m|
      puts "  - #{m['id']} (#{m['state']})"
    end
  end
  puts "Will update #{machine_ids.length} active machines: #{machine_ids.join(', ')}" if machine_ids.any?
  puts "\n"

  if machine_ids.empty?
    puts "No active machines to update"
    exit 0
  end
end

# Step 3: Call update_config CGI endpoint on each machine
puts "Step 3: Triggering configuration update on each machine..."
puts "=" * 50

# Set URI based on target platform
uri = if options[:target] == :kamal
  URI.parse('https://showcase.party/update_config')
else
  URI.parse('https://smooth.fly.dev/showcase/update_config')
end

success_count = 0
failure_count = 0

# Helper method to attempt updating a machine
def attempt_update(uri, machine_id, verbose, target)
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true
  http.read_timeout = 30
  http.open_timeout = 10

  request = Net::HTTP::Post.new(uri.path)
  # Only set Fly-Force-Instance-Id header for Fly.io targets
  request['Fly-Force-Instance-Id'] = machine_id if target.to_s == 'fly'

  response = http.request(request)

  if response.code == '200'
    # Always print response body to see CGI script output/errors
    if response.body && !response.body.empty?
      puts "  Response body:"
      puts response.body
    end
    return { success: true }
  else
    return { success: false, error: "HTTP #{response.code}: #{response.body}" }
  end
rescue => e
  return { success: false, error: e.message }
end

# Track machines that need retrying
pending_machines = machine_ids.map { |id| { id: id, attempts: 0 } }
max_retries = 3

# Process machines in rounds, moving to next machine on failure
round = 1
while pending_machines.any? && round <= max_retries
  puts "\nRound #{round}:" if round > 1

  failed_machines = []

  pending_machines.each do |machine|
    machine_id = machine[:id]
    attempt_num = machine[:attempts] + 1

    if options[:dry_run]
      print "  #{machine_id}... "
      puts "(dry run - would POST to #{uri} with Fly-Force-Instance-Id: #{machine_id})"
      success_count += 1
    else
      print "  #{machine_id}... "
      result = attempt_update(uri, machine_id, options[:verbose], options[:target])

      if result[:success]
        puts "✓ Success"
        success_count += 1
      else
        if attempt_num < max_retries
          puts "✗ Error (attempt #{attempt_num}/#{max_retries}): #{result[:error]}"
          failed_machines << { id: machine_id, attempts: attempt_num }
        else
          puts "✗ Failed after #{max_retries} attempts: #{result[:error]}"
          failure_count += 1
        end
      end
    end
  end

  # Update pending machines for next round
  pending_machines = failed_machines
  round += 1

  # Wait between rounds if there are machines to retry
  if pending_machines.any?
    wait_time = 5
    puts "\nWaiting #{wait_time} seconds before retrying #{pending_machines.length} machine(s)..."
    sleep wait_time
  end
end

puts "\n"
puts "Summary:"
puts "=" * 50
puts "Successfully updated: #{success_count} machines"
puts "Failed updates: #{failure_count} machines" if failure_count > 0

exit(failure_count > 0 ? 1 : 0)
